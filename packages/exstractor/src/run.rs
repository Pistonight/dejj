use std::path::Path;
use std::sync::Arc;

use cu::pre::*;
use dejj_utils::Config;
use llvmutils::Demangler;
use symlist::SymbolList;

use crate::dwarf::Dwarf;
use crate::dwarf_loader;
use crate::hstage;
use crate::lstage;
use crate::mstage;
use crate::stages::StageInfo;

pub fn run(config: Config) -> cu::Result<()> {
    cu::fs::make_dir(&config.paths.extract_output)?;
    // build the project to generate the ELF
    // usually this should be fast since the build is incremental
    {
        // unwrap: config is validated
        let build_bin = config.extract.build_command.first().unwrap();
        let (child, _, bar) = Path::new(build_bin)
            .command()
            .args(config.extract.build_command.iter().skip(1))
            .current_dir(&config.paths.build_dir)
            .stdoe(cu::pio::spinner("build project"))
            .stdin_null()
            .spawn()?;
        child.wait_nz()?;
        bar.done();
    }

    let config = Arc::new(config);

    // parse the compile_commands.json file generated by building the project (cmake)
    let compile_commands = llvmutils::parse_compdb(&config.paths.compdb)?;
    let demangler_cache = config.paths.extract_output.join("demangler_cache.json");
    let demangler = Arc::new(Demangler::try_new(demangler_cache)?);
    let symbol_list = {
        let config = Arc::clone(&config);
        let demangler = Arc::clone(&demangler);
        let mut symbol_list = SymbolList::default();
        symbol_list.load_data(&config.paths.data_csv)?;
        let symbol_list = cu::co::run(async move {
            symbol_list
                .load_func(&config.paths.functions_csv, demangler)
                .await?;
            cu::Ok(symbol_list)
        })?;
        cu::info!("loaded {} symbols from listing", symbol_list.len());
        symbol_list
    };
    let symbol_list = Arc::new(symbol_list);
    if let Err(e) = demangler.flush_cache() {
        cu::warn!("failed to flush demangler cache: {e:?}");
    }

    // parse DWARF
    let bytes: Arc<[u8]> = cu::fs::read(&config.paths.elf)?.into();
    let dwarf = Dwarf::try_parse(bytes)?;

    let units = {
        let mut units = Vec::new();
        let mut iter = Dwarf::iter_units(&dwarf);
        while let Some(unit) = iter
            .next_unit()
            .context("error while collecting units from DWARF")?
        {
            units.push(unit);
        }
        cu::info!("found {} compilation units", units.len());
        units
    };

    let stages = {
        let config = Arc::clone(&config);
        let symbol_list = Arc::clone(&symbol_list);
        let stages = cu::co::run(async move {
            let bar = cu::progress("stage0: loading types")
                .total(units.len())
                .spawn();
            let mut handles = Vec::with_capacity(units.len());
            let pool = cu::co::pool(-1);
            let mut output = Vec::with_capacity(units.len());

            for unit in units {
                let config = Arc::clone(&config);
                let symbol_list = Arc::clone(&symbol_list);
                let handle = pool.spawn(async move {
                    let ns = dwarf_loader::load_namespaces(&unit)?;
                    let stage0 = dwarf_loader::load_lstage(&unit, config, ns, symbol_list)?;
                    cu::Ok(stage0)
                });
                handles.push(handle);
            }

            let mut set = cu::co::set(handles);
            while let Some(result) = set.next().await {
                let stage = result??;
                cu::progress!(bar += 1, "{}", stage.name);
                output.push(stage);
            }
            output.sort_unstable_by_key(|x| x.offset);
            cu::Ok(output)
        })?;

        let mut info = StageInfo::new(0);
        stages.iter().for_each(|x| info.add_lstage(x));
        info.print();

        stages
    };

    let stages = {
        let compile_commands = compile_commands.clone();
        let stages = cu::co::run(async move {
            let bar = cu::progress("stage0 -> stage1: reducing types")
                .total(stages.len())
                .spawn();
            let mut handles = Vec::with_capacity(stages.len());
            let pool = cu::co::pool(-1);
            let mut output = Vec::with_capacity(stages.len());

            for stage in stages {
                let name = &stage.name;
                let command = cu::check!(
                    compile_commands.get(name),
                    "cannot find compile command for {name}"
                )?;
                let command = command.clone();
                let handle = pool.spawn(async move { lstage::to_mstage(stage, command).await });
                handles.push(handle);
            }

            let mut set = cu::co::set(handles);
            while let Some(result) = set.next().await {
                let stage = result??;
                cu::progress!(bar += 1, "{}", stage.name);
                output.push(stage);
            }
            drop(bar);
            output.sort_unstable_by_key(|x| x.offset);
            cu::Ok(output)
        })?;

        let mut info = StageInfo::new(1);
        stages.iter().for_each(|x| info.add_mstage(x));
        info.print();

        stages
    };

    let stage = cu::co::run(async move { mstage::link_mstages(stages).await })?;
    StageInfo::mstage2(&stage).print();
    if config.extract.debug.mstage {
        let debug_info = format!(
            "/* The .rs extension is only for syntax highlighting and the macro is to suppress syntax errors */ mstage!{{{:#?}}}",
            stage.types
        );
        let out_path = config.paths.extract_output.join("mstage.rs");
        match cu::fs::write(&out_path, debug_info) {
            Ok(()) => cu::hint!(
                "mstage debug info saved to {}",
                out_path.try_to_rel().display()
            ),
            Err(e) => {
                cu::warn!("failed to save mstage debug info: {e:?}");
            }
        }
    }

    let stage = hstage::from_mstage(stage)?;
    StageInfo::hstage3(&stage).print();
    if config.extract.debug.hstage {
        let debug_info = format!(
            "/* The .rs extension is only for syntax highlighting and the macro is to suppress syntax errors */ mstage!{{{:#?}}}",
            stage.types
        );
        let out_path = config.paths.extract_output.join("hstage.rs");
        match cu::fs::write(&out_path, debug_info) {
            Ok(()) => cu::hint!(
                "hstage debug info saved to {}",
                out_path.try_to_rel().display()
            ),
            Err(e) => {
                cu::warn!("failed to save hstage debug info: {e:?}");
            }
        }
    }

    cu::hint!("todo");

    Ok(())
}
